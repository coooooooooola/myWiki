import comp from "/Users/swtywang/Coding/05 我的博客/my-docs-new/src/.vuepress/.temp/pages/posts/后端开发/03 Java栈 - 动态代理.html.vue"
const data = JSON.parse("{\"path\":\"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/03%20Java%E6%A0%88%20-%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html\",\"title\":\"Java栈 - 动态代理\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"Java栈 - 动态代理\",\"date\":\"2022-01-23T00:00:00.000Z\",\"cover\":\"/ssets/images/cover3.jpg\",\"shortTitle\":\"Java栈 - 动态代理\",\"useHeaderImage\":false,\"headerMask\":\"rgba(40, 57, 101, .4)\",\"catalog\":true,\"tags\":[\"Java\",\"server\",\"质量架构\"],\"gitInclude\":[],\"description\":\"1. 代理的作用 在不侵入原有代码的前提下实现代码增强，比如说在目标对象的某个方法执行前后可以增加一些自定义的操作。 2. 静态代理 静态代理中，我们对目标对象的每个方法的增强都是手动完成的，这种代理方式需要代理对象和目标对象实现一样的接口。 从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。 ...\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://swtywang/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/03%20Java%E6%A0%88%20-%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"swtywang's homepage\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"Java栈 - 动态代理\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"1. 代理的作用 在不侵入原有代码的前提下实现代码增强，比如说在目标对象的某个方法执行前后可以增加一些自定义的操作。 2. 静态代理 静态代理中，我们对目标对象的每个方法的增强都是手动完成的，这种代理方式需要代理对象和目标对象实现一样的接口。 从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。 ...\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:image\",\"content\":\"https://swtywang/ssets/images/cover3.jpg\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"meta\",{\"name\":\"twitter:image:src\",\"content\":\"https://swtywang/ssets/images/cover3.jpg\"}],[\"meta\",{\"name\":\"twitter:image:alt\",\"content\":\"Java栈 - 动态代理\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"Java\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"server\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"质量架构\"}],[\"meta\",{\"property\":\"article:published_time\",\"content\":\"2022-01-23T00:00:00.000Z\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"Java栈 - 动态代理\\\",\\\"image\\\":[\\\"https://swtywang.fun/minio//blog/0acffb42123846bd493b246500b8f523.jpg\\\"],\\\"datePublished\\\":\\\"2022-01-23T00:00:00.000Z\\\",\\\"dateModified\\\":null,\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"swtywang\\\",\\\"url\\\":\\\"https:www.baidu.com\\\"}]}\"]]},\"headers\":[{\"level\":2,\"title\":\"1. 代理的作用\",\"slug\":\"_1-代理的作用\",\"link\":\"#_1-代理的作用\",\"children\":[]},{\"level\":2,\"title\":\"2. 静态代理\",\"slug\":\"_2-静态代理\",\"link\":\"#_2-静态代理\",\"children\":[{\"level\":3,\"title\":\"2.1 静态代理 Demo\",\"slug\":\"_2-1-静态代理-demo\",\"link\":\"#_2-1-静态代理-demo\",\"children\":[]}]},{\"level\":2,\"title\":\"3. JDK 动态代理\",\"slug\":\"_3-jdk-动态代理\",\"link\":\"#_3-jdk-动态代理\",\"children\":[{\"level\":3,\"title\":\"3.1 JDK 动态代理 DEMO\",\"slug\":\"_3-1-jdk-动态代理-demo\",\"link\":\"#_3-1-jdk-动态代理-demo\",\"children\":[]},{\"level\":3,\"title\":\"3.2 运行过程&原理分析\",\"slug\":\"_3-2-运行过程-原理分析\",\"link\":\"#_3-2-运行过程-原理分析\",\"children\":[]},{\"level\":3,\"title\":\"3.3 JDK 动态代理的局限\",\"slug\":\"_3-3-jdk-动态代理的局限\",\"link\":\"#_3-3-jdk-动态代理的局限\",\"children\":[]},{\"level\":3,\"title\":\"4. cglib 动态代理\",\"slug\":\"_4-cglib-动态代理\",\"link\":\"#_4-cglib-动态代理\",\"children\":[]},{\"level\":3,\"title\":\"4.1 DEMO\",\"slug\":\"_4-1-demo\",\"link\":\"#_4-1-demo\",\"children\":[]},{\"level\":3,\"title\":\"4.2 动态代理类的生成过程\",\"slug\":\"_4-2-动态代理类的生成过程\",\"link\":\"#_4-2-动态代理类的生成过程\",\"children\":[]},{\"level\":3,\"title\":\"4.3 动态代理类调用方法的过程\",\"slug\":\"_4-3-动态代理类调用方法的过程\",\"link\":\"#_4-3-动态代理类调用方法的过程\",\"children\":[]}]},{\"level\":2,\"title\":\"5. jdk 动态代理 vs cglib 动态代理\",\"slug\":\"_5-jdk-动态代理-vs-cglib-动态代理\",\"link\":\"#_5-jdk-动态代理-vs-cglib-动态代理\",\"children\":[]},{\"level\":2,\"title\":\"6. 动态代理的使用场景\",\"slug\":\"_6-动态代理的使用场景\",\"link\":\"#_6-动态代理的使用场景\",\"children\":[{\"level\":3,\"title\":\"6.1 AOP\",\"slug\":\"_6-1-aop\",\"link\":\"#_6-1-aop\",\"children\":[]},{\"level\":3,\"title\":\"6.2 流量录制回放平台/MOCK\",\"slug\":\"_6-2-流量录制回放平台-mock\",\"link\":\"#_6-2-流量录制回放平台-mock\",\"children\":[]},{\"level\":3,\"title\":\"6.3 Mybatis-mapper\",\"slug\":\"_6-3-mybatis-mapper\",\"link\":\"#_6-3-mybatis-mapper\",\"children\":[]}]}],\"readingTime\":{\"minutes\":14.89,\"words\":4467},\"filePathRelative\":\"posts/后端开发/03 Java栈 - 动态代理.md\",\"localizedDate\":\"2022年1月23日\",\"excerpt\":\"<h2>1. 代理的作用</h2>\\n<p>在不侵入原有代码的前提下实现代码增强，<strong>比如说在目标对象的某个方法执行前后可以增加一些自定义的操作。</strong></p>\\n<h2>2. 静态代理</h2>\\n<p>静态代理中，我们对目标对象的每个方法的增强都是手动完成的，这种代理方式需要代理对象和目标对象实现一样的接口。</p>\\n<p>从 JVM 层面来说， 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</p>\\n<p>优点：可以在不修改目标对象的前提下扩展目标对象的功能。</p>\\n<p>缺点：</p>\\n<ol>\\n<li>冗余。由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。</li>\\n<li>不易维护。一旦接口增加方法，目标对象与代理对象都要进行修改。</li>\\n</ol>\",\"autoDesc\":true}")
export { comp, data }

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
