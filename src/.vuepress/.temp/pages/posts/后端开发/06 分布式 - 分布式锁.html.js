import comp from "/Users/swtywang/Coding/05 我的博客/my-docs-new/src/.vuepress/.temp/pages/posts/后端开发/06 分布式 - 分布式锁.html.vue"
const data = JSON.parse("{\"path\":\"/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/06%20%E5%88%86%E5%B8%83%E5%BC%8F%20-%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html\",\"title\":\"分布式 - 分布式锁\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"分布式 - 分布式锁\",\"date\":\"2021-05-12T00:00:00.000Z\",\"cover\":\"/assets/images/cover4.jpg\",\"headerMask\":\"rgba(40, 57, 101, .4)\",\"catalog\":true,\"tags\":[\"Java\",\"微服务\",\"server\"],\"gitInclude\":[],\"description\":\"1. 背景 我们在日常的工作中，有时候会碰到一些高并发的场景，比如，电商业务场景下的秒杀活动，春节活动中的抢红包，银行转账，出行抢票等，这些场景有一个共同特点就是在短时间内存在极高的峰值 qps。虽然在系统设计中，我们会通过异步限流、削峰填谷等方式进行优化，但整体的系统流量还是会在平时的数倍以上。因此，为了避免高并发带来的问题（如库存超卖，代金券超发等...\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://swtywang/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/06%20%E5%88%86%E5%B8%83%E5%BC%8F%20-%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"swtywang's homepage\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"分布式 - 分布式锁\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"1. 背景 我们在日常的工作中，有时候会碰到一些高并发的场景，比如，电商业务场景下的秒杀活动，春节活动中的抢红包，银行转账，出行抢票等，这些场景有一个共同特点就是在短时间内存在极高的峰值 qps。虽然在系统设计中，我们会通过异步限流、削峰填谷等方式进行优化，但整体的系统流量还是会在平时的数倍以上。因此，为了避免高并发带来的问题（如库存超卖，代金券超发等...\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:image\",\"content\":\"https://swtywang/assets/images/cover4.jpg\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"meta\",{\"name\":\"twitter:image:src\",\"content\":\"https://swtywang/assets/images/cover4.jpg\"}],[\"meta\",{\"name\":\"twitter:image:alt\",\"content\":\"分布式 - 分布式锁\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"Java\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"微服务\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"server\"}],[\"meta\",{\"property\":\"article:published_time\",\"content\":\"2021-05-12T00:00:00.000Z\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"分布式 - 分布式锁\\\",\\\"image\\\":[\\\"https://swtywang.fun/minio/blog/182287db00957bce90b5ab6b3359f33f.jpg\\\",\\\"https://swtywang.fun/minio/blog/6083e73e72278f72ace5bab765a2474c.jpg\\\",\\\"https://swtywang.fun/minio/blog/65c0e08da0ab1c71974f45acea56c876.jpg\\\",\\\"https://swtywang.fun/minio/blog/19d3283b28c90b2902f8b6d6fe2bbe3f.jpg\\\"],\\\"datePublished\\\":\\\"2021-05-12T00:00:00.000Z\\\",\\\"dateModified\\\":null,\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"swtywang\\\",\\\"url\\\":\\\"https:www.baidu.com\\\"}]}\"]]},\"headers\":[{\"level\":2,\"title\":\"1. 背景\",\"slug\":\"_1-背景\",\"link\":\"#_1-背景\",\"children\":[]},{\"level\":2,\"title\":\"2. 什么是分布式锁\",\"slug\":\"_2-什么是分布式锁\",\"link\":\"#_2-什么是分布式锁\",\"children\":[]},{\"level\":2,\"title\":\"3. 分布式锁的实现方式\",\"slug\":\"_3-分布式锁的实现方式\",\"link\":\"#_3-分布式锁的实现方式\",\"children\":[{\"level\":3,\"title\":\"3.1 MySQL\",\"slug\":\"_3-1-mysql\",\"link\":\"#_3-1-mysql\",\"children\":[]},{\"level\":3,\"title\":\"3.2 Redis 分布式锁\",\"slug\":\"_3-2-redis-分布式锁\",\"link\":\"#_3-2-redis-分布式锁\",\"children\":[]},{\"level\":3,\"title\":\"3.3 Zookeeper 分布式锁\",\"slug\":\"_3-3-zookeeper-分布式锁\",\"link\":\"#_3-3-zookeeper-分布式锁\",\"children\":[]},{\"level\":3,\"title\":\"3.4 Memcached 分布式锁\",\"slug\":\"_3-4-memcached-分布式锁\",\"link\":\"#_3-4-memcached-分布式锁\",\"children\":[]},{\"level\":3,\"title\":\"3.5 Chubby\",\"slug\":\"_3-5-chubby\",\"link\":\"#_3-5-chubby\",\"children\":[]}]},{\"level\":2,\"title\":\"4. 基于数据库实现的分布式锁\",\"slug\":\"_4-基于数据库实现的分布式锁\",\"link\":\"#_4-基于数据库实现的分布式锁\",\"children\":[{\"level\":3,\"title\":\"4.1 基于表实现的分布式锁［非阻塞］\",\"slug\":\"_4-1-基于表实现的分布式锁-非阻塞\",\"link\":\"#_4-1-基于表实现的分布式锁-非阻塞\",\"children\":[]},{\"level\":3,\"title\":\"4.2 基于排他锁实现的分布式锁［阻塞锁］\",\"slug\":\"_4-2-基于排他锁实现的分布式锁-阻塞锁\",\"link\":\"#_4-2-基于排他锁实现的分布式锁-阻塞锁\",\"children\":[]},{\"level\":3,\"title\":\"4.3 总结\",\"slug\":\"_4-3-总结\",\"link\":\"#_4-3-总结\",\"children\":[]}]},{\"level\":2,\"title\":\"5. 基于 Redis 实现的分布式锁\",\"slug\":\"_5-基于-redis-实现的分布式锁\",\"link\":\"#_5-基于-redis-实现的分布式锁\",\"children\":[{\"level\":3,\"title\":\"5.1 SETNX\",\"slug\":\"_5-1-setnx\",\"link\":\"#_5-1-setnx\",\"children\":[]},{\"level\":3,\"title\":\"5.2 SETNX + EXPIRE / SET（NX + EX）\",\"slug\":\"_5-2-setnx-expire-set-nx-ex\",\"link\":\"#_5-2-setnx-expire-set-nx-ex\",\"children\":[]},{\"level\":3,\"title\":\"5.2.3 总结\",\"slug\":\"_5-2-3-总结\",\"link\":\"#_5-2-3-总结\",\"children\":[]},{\"level\":3,\"title\":\"5.3 SET + EX + NX + 校验唯一随机值\",\"slug\":\"_5-3-set-ex-nx-校验唯一随机值\",\"link\":\"#_5-3-set-ex-nx-校验唯一随机值\",\"children\":[]},{\"level\":3,\"title\":\"5.4 开源框架：Redisson\",\"slug\":\"_5-4-开源框架-redisson\",\"link\":\"#_5-4-开源框架-redisson\",\"children\":[]},{\"level\":3,\"title\":\"5.5 多机实现的分布式锁 Redlock + Redisson\",\"slug\":\"_5-5-多机实现的分布式锁-redlock-redisson\",\"link\":\"#_5-5-多机实现的分布式锁-redlock-redisson\",\"children\":[]},{\"level\":3,\"title\":\"5.6 Redis 分布式锁总结\",\"slug\":\"_5-6-redis-分布式锁总结\",\"link\":\"#_5-6-redis-分布式锁总结\",\"children\":[]}]},{\"level\":2,\"title\":\"6. 总结\",\"slug\":\"_6-总结\",\"link\":\"#_6-总结\",\"children\":[{\"level\":3,\"title\":\"6.1 文档中方案的比较\",\"slug\":\"_6-1-文档中方案的比较\",\"link\":\"#_6-1-文档中方案的比较\",\"children\":[]},{\"level\":3,\"title\":\"6.2 一些通用的总结\",\"slug\":\"_6-2-一些通用的总结\",\"link\":\"#_6-2-一些通用的总结\",\"children\":[]}]},{\"level\":2,\"title\":\"7. 项目遇到的分布式锁\",\"slug\":\"_7-项目遇到的分布式锁\",\"link\":\"#_7-项目遇到的分布式锁\",\"children\":[{\"level\":3,\"title\":\"7.1 B 端后台防止同时操作同一条数据 - redis\",\"slug\":\"_7-1-b-端后台防止同时操作同一条数据-redis\",\"link\":\"#_7-1-b-端后台防止同时操作同一条数据-redis\",\"children\":[]},{\"level\":3,\"title\":\"7.2 乐观锁 - MySQL\",\"slug\":\"_7-2-乐观锁-mysql\",\"link\":\"#_7-2-乐观锁-mysql\",\"children\":[]}]}],\"readingTime\":{\"minutes\":18.64,\"words\":5592},\"filePathRelative\":\"posts/后端开发/06 分布式 - 分布式锁.md\",\"localizedDate\":\"2021年5月12日\",\"excerpt\":\"<h2>1. 背景</h2>\\n<p>我们在日常的工作中，有时候会碰到一些高并发的场景，比如，电商业务场景下的秒杀活动，春节活动中的抢红包，银行转账，出行抢票等，这些场景有一个共同特点就是在短时间内存在极高的峰值 qps。虽然在系统设计中，我们会通过异步限流、削峰填谷等方式进行优化，但整体的系统流量还是会在平时的数倍以上。因此，为了避免高并发带来的问题（如库存超卖，代金券超发等），这些系统通常都会用到锁的机制。</p>\\n<p>对于单进程的并发场景，可以使用编程语言及相应的类库提供的锁，如 Java 中的 synchronized 语法以及 ReentrantLock 类，Golang 中的 sync 包等，避免并发问题。在实际的业务场景中，一般均为多实例部署，因此不在此处做过多的篇幅介绍。</p>\",\"autoDesc\":true}")
export { comp, data }

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
